/* tslint:disable */
/* eslint-disable */
/**
 * Triple A API
 * This is the swagger with reference to https://developers.triple-a.io/docs/triplea-api-doc
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@triple-a.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Detailed Authentication Response with Access Token Required for subsequent calls
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'token_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthResponse
     */
    'expires_in'?: number;
}
/**
 * item
 * @export
 * @interface CartItem
 */
export interface CartItem {
    /**
     * Stock Keeping Unit of the item
     * @type {string}
     * @memberof CartItem
     */
    'sku'?: string;
    /**
     * Name and/or description of the item
     * @type {string}
     * @memberof CartItem
     */
    'label'?: string;
    /**
     * Number of units of the item
     * @type {number}
     * @memberof CartItem
     */
    'quantity'?: number;
    /**
     * Total price of all the units of the item
     * @type {number}
     * @memberof CartItem
     */
    'amount'?: number;
}
/**
 * balance of a specific currency
 * @export
 * @interface CurrencyBalance
 */
export interface CurrencyBalance {
    /**
     * 
     * @type {string}
     * @memberof CurrencyBalance
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyBalance
     */
    'available_currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyBalance
     */
    'available_amount'?: number;
}
/**
 * merchant balance
 * @export
 * @interface MerchantBalance
 */
export interface MerchantBalance {
    /**
     * 
     * @type {string}
     * @memberof MerchantBalance
     */
    'merchant_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantBalance
     */
    'merchant_name'?: string;
    /**
     * 
     * @type {Array<CurrencyBalance>}
     * @memberof MerchantBalance
     */
    'balances'?: Array<CurrencyBalance>;
}
/**
 * 
 * @export
 * @interface Model401Error
 */
export interface Model401Error {
    /**
     * 
     * @type {string}
     * @memberof Model401Error
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Model422Error
 */
export interface Model422Error {
    /**
     * 
     * @type {string}
     * @memberof Model422Error
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ValidationErrorItem>}
     * @memberof Model422Error
     */
    'errors'?: Array<ValidationErrorItem>;
}
/**
 * Payment Response Object
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * Unique Payment Reference Number that identifies this payment
     * @type {string}
     * @memberof Payment
     */
    'payment_reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'order_currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'order_amount'?: number;
    /**
     * Exchange rate is guaranteed until the expiry date.
     * @type {string}
     * @memberof Payment
     */
    'expiry_date'?: string;
    /**
     * Redirect the payer\'s browser to this URL for them to make payment
     * @type {string}
     * @memberof Payment
     */
    'hosted_url'?: string;
    /**
     * Oauth2 access token used specifically for this payment request
     * @type {string}
     * @memberof Payment
     */
    'access_token'?: string;
    /**
     * Bearer
     * @type {string}
     * @memberof Payment
     */
    'token_type'?: string;
    /**
     * until the access_token expires
     * @type {number}
     * @memberof Payment
     */
    'expires_in'?: number;
    /**
     * The shared secret that will be used to sign the notification. If the secret was provided in the payment request, it will be mirrored here. If not a random secret will be generated
     * @type {string}
     * @memberof Payment
     */
    'notify_secret'?: string;
}
/**
 * Payment Request Object
 * @export
 * @interface PaymentRequest
 */
export interface PaymentRequest {
    /**
     * use triplea for external URL Payment Form and widget for hosted_url to be displayed on iframe or Webview
     * @type {string}
     * @memberof PaymentRequest
     */
    'type': PaymentRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentRequest
     */
    'merchant_key': string;
    /**
     * follow the 3-character from https://en.wikipedia.org/wiki/ISO_4217
     * @type {string}
     * @memberof PaymentRequest
     */
    'order_currency': string;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequest
     */
    'order_amount': number;
    /**
     * Where to send the email notification for this payment request
     * @type {string}
     * @memberof PaymentRequest
     */
    'notify_email'?: string;
    /**
     * The URL to send the webhook notification
     * @type {string}
     * @memberof PaymentRequest
     */
    'notify_url'?: string;
    /**
     * The shared secret that will be used to sign the notification. This secret can be at most 64 characters long.
     * @type {string}
     * @memberof PaymentRequest
     */
    'notify_secret'?: string;
    /**
     * Flag to include the individual txs in the webhook notification
     * @type {boolean}
     * @memberof PaymentRequest
     */
    'notify_txs'?: boolean;
    /**
     * Idempotency key. Merchant\'s unique ID for the payout
     * @type {string}
     * @memberof PaymentRequest
     */
    'order_id'?: string;
    /**
     * The merchant needs to provide a unique ID for each payer. If the merchant does not have a unique ID then use the payerâ€™s email address.
     * @type {string}
     * @memberof PaymentRequest
     */
    'payer_id'?: string;
    /**
     * If you do not have the payer\'s name, then leave this key out of the JSON object. Do not submit an empty string \"\".
     * @type {string}
     * @memberof PaymentRequest
     */
    'payer_name'?: string;
    /**
     * If you do not have the payer\'s email, then leave this key out of the JSON object. Do not submit an empty string \"\"
     * @type {string}
     * @memberof PaymentRequest
     */
    'payer_email'?: string;
    /**
     * Payer\'s phone number in E.164 format.  If you do not have the payer\'s phone number, then leave this key out of the JSON object. Do not submit an empty string \"\"
     * @type {string}
     * @memberof PaymentRequest
     */
    'payer_phone'?: string;
    /**
     * Do not submit an empty string \"\"
     * @type {string}
     * @memberof PaymentRequest
     */
    'payer_address'?: string;
    /**
     * URL to the payer\'s Proof-Of-Identity (POI). Our system will download the payer\'s POI from this link.
     * @type {string}
     * @memberof PaymentRequest
     */
    'payer_poi'?: string;
    /**
     * IP address of the payer
     * @type {string}
     * @memberof PaymentRequest
     */
    'payer_ip'?: string;
    /**
     * Webpage to redirect the customer to on successful payment.
     * @type {string}
     * @memberof PaymentRequest
     */
    'success_url'?: string;
    /**
     * Webpage to redirect the customer to on cancelled payment
     * @type {string}
     * @memberof PaymentRequest
     */
    'cancel_url'?: string;
    /**
     * 
     * @type {PaymentRequestCart}
     * @memberof PaymentRequest
     */
    'cart'?: PaymentRequestCart;
    /**
     * We recommend that you at least include the order_id which ties this payment request to the order in your system.
     * @type {object}
     * @memberof PaymentRequest
     */
    'webhook_data'?: object;
    /**
     * 
     * @type {SubMerchant}
     * @memberof PaymentRequest
     */
    'sub_merchant'?: SubMerchant;
}

export const PaymentRequestTypeEnum = {
    Triplea: 'triplea',
    Widget: 'widget'
} as const;

export type PaymentRequestTypeEnum = typeof PaymentRequestTypeEnum[keyof typeof PaymentRequestTypeEnum];

/**
 * Optional Shopping Cart
 * @export
 * @interface PaymentRequestCart
 */
export interface PaymentRequestCart {
    /**
     * 
     * @type {Array<CartItem>}
     * @memberof PaymentRequestCart
     */
    'items'?: Array<CartItem>;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequestCart
     */
    'shipping_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequestCart
     */
    'shipping_discount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentRequestCart
     */
    'tax_cost'?: number;
}
/**
 * details of submerchant
 * @export
 * @interface SubMerchant
 */
export interface SubMerchant {
    /**
     * ID of Submerchant
     * @type {string}
     * @memberof SubMerchant
     */
    'id'?: string;
    /**
     * Name of the Submerchant
     * @type {string}
     * @memberof SubMerchant
     */
    'name'?: string;
    /**
     * Phone Number of Submerchant
     * @type {string}
     * @memberof SubMerchant
     */
    'phone_number'?: string;
    /**
     * Email of Submerchant
     * @type {string}
     * @memberof SubMerchant
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface ValidationErrorItem
 */
export interface ValidationErrorItem {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorItem
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorItem
     */
    'path'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authentication
         * @param {string} [clientId] Client ID provided during sign up
         * @param {string} [clientSecret] Client Secret provided during sign up
         * @param {string} [grantType] Desired grant_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeUser: async (clientId?: string, clientSecret?: string, grantType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authentication
         * @param {string} [clientId] Client ID provided during sign up
         * @param {string} [clientSecret] Client Secret provided during sign up
         * @param {string} [grantType] Desired grant_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeUser(clientId?: string, clientSecret?: string, grantType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeUser(clientId, clientSecret, grantType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authentication
         * @param {string} [clientId] Client ID provided during sign up
         * @param {string} [clientSecret] Client Secret provided during sign up
         * @param {string} [grantType] Desired grant_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeUser(clientId?: string, clientSecret?: string, grantType?: string, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.authorizeUser(clientId, clientSecret, grantType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authentication
     * @param {string} [clientId] Client ID provided during sign up
     * @param {string} [clientSecret] Client Secret provided during sign up
     * @param {string} [grantType] Desired grant_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authorizeUser(clientId?: string, clientSecret?: string, grantType?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authorizeUser(clientId, clientSecret, grantType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint covers the two use-cases of external-url-payment and embedded payment form
         * @summary Create payment request
         * @param {PaymentRequest} body Payment Request that would be used to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentRequest: async (body: PaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPaymentRequest', 'body', body)
            const localVarPath = `/payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer_auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint covers the two use-cases of external-url-payment and embedded payment form
         * @summary Create payment request
         * @param {PaymentRequest} body Payment Request that would be used to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentRequest(body: PaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentRequest(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * This endpoint covers the two use-cases of external-url-payment and embedded payment form
         * @summary Create payment request
         * @param {PaymentRequest} body Payment Request that would be used to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentRequest(body: PaymentRequest, options?: any): AxiosPromise<Payment> {
            return localVarFp.createPaymentRequest(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * This endpoint covers the two use-cases of external-url-payment and embedded payment form
     * @summary Create payment request
     * @param {PaymentRequest} body Payment Request that would be used to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createPaymentRequest(body: PaymentRequest, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createPaymentRequest(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayoutApi - axios parameter creator
 * @export
 */
export const PayoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Available balance in merchant\'s preferred local currency
         * @summary Available balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutBalance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payout/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer_auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutApi - functional programming interface
 * @export
 */
export const PayoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Available balance in merchant\'s preferred local currency
         * @summary Available balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayoutBalance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MerchantBalance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutBalance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayoutApi - factory interface
 * @export
 */
export const PayoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutApiFp(configuration)
    return {
        /**
         * Available balance in merchant\'s preferred local currency
         * @summary Available balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutBalance(options?: any): AxiosPromise<Array<MerchantBalance>> {
            return localVarFp.getPayoutBalance(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutApi - object-oriented interface
 * @export
 * @class PayoutApi
 * @extends {BaseAPI}
 */
export class PayoutApi extends BaseAPI {
    /**
     * Available balance in merchant\'s preferred local currency
     * @summary Available balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public getPayoutBalance(options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).getPayoutBalance(options).then((request) => request(this.axios, this.basePath));
    }
}


